// hip_recfg_slave.v

// Generated using ACDS version 24.3 212

`timescale 1 ps / 1 ps
module hip_recfg_slave #(
		parameter DATA_WIDTH          = 8,
		parameter SYMBOL_WIDTH        = 8,
		parameter HDL_ADDR_WIDTH      = 24,
		parameter BURSTCOUNT_WIDTH    = 1,
		parameter COMMAND_FIFO_DEPTH  = 4,
		parameter RESPONSE_FIFO_DEPTH = 4,
		parameter MASTER_SYNC_DEPTH   = 2,
		parameter SLAVE_SYNC_DEPTH    = 2,
		parameter SYNC_RESET          = 1
	) (
		input  wire                        m0_clk,           //   m0_clk.clk,           Clock input
		input  wire                        m0_reset,         // m0_reset.reset,         Reset input
		input  wire                        s0_clk,           //   s0_clk.clk,           Clock input
		input  wire                        s0_reset,         // s0_reset.reset,         Reset input
		output wire                        s0_waitrequest,   //       s0.waitrequest,   Wait request to Avalon Memory Mapped Host, indicates agent is not ready
		output wire [DATA_WIDTH-1:0]       s0_readdata,      //         .readdata,      Read Data output from Avalon Memory Mapped Agent
		output wire                        s0_readdatavalid, //         .readdatavalid, Valid read data indication from Avalon Memory Mapped Agent
		input  wire [BURSTCOUNT_WIDTH-1:0] s0_burstcount,    //         .burstcount,    Indicates number of burst transfers in each burst
		input  wire [DATA_WIDTH-1:0]       s0_writedata,     //         .writedata,     Write Data from Avalon Memory Mapped Host
		input  wire [HDL_ADDR_WIDTH-1:0]   s0_address,       //         .address,       Address output from Avalon Memory Mapped Host
		input  wire                        s0_write,         //         .write,         Write command from Avalon Memory Mapped Host
		input  wire                        s0_read,          //         .read,          Read command from Avalon Memory Mapped Host
		input  wire [0:0]                  s0_byteenable,    //         .byteenable,    Indicates valid read/write data location
		input  wire                        s0_debugaccess,   //         .debugaccess
		input  wire                        m0_waitrequest,   //       m0.waitrequest,   Wait request from Avalon Memory Mapped Agent, indicates agent is not ready
		input  wire [DATA_WIDTH-1:0]       m0_readdata,      //         .readdata,      Read Data input to Avalon Memory Mapped Host
		input  wire                        m0_readdatavalid, //         .readdatavalid, Valid read data indication from Avalon Memory Mapped Agent
		output wire [BURSTCOUNT_WIDTH-1:0] m0_burstcount,    //         .burstcount,    Indicates number of burst transfers in each burst
		output wire [DATA_WIDTH-1:0]       m0_writedata,     //         .writedata,     Write Data from Avalon Memory Mapped Host
		output wire [HDL_ADDR_WIDTH-1:0]   m0_address,       //         .address,       Address output from Avalon Memory Mapped Host
		output wire                        m0_write,         //         .write,         Write command from Avalon Memory Mapped Host
		output wire                        m0_read,          //         .read,          Read command from Avalon Memory Mapped Host
		output wire [0:0]                  m0_byteenable,    //         .byteenable,    Indicates valid read/write data location
		output wire                        m0_debugaccess    //         .debugaccess
	);

	hip_recfg_slave_mm_ccb_1921_sja7pia #(
		.DATA_WIDTH          (DATA_WIDTH),
		.SYMBOL_WIDTH        (SYMBOL_WIDTH),
		.HDL_ADDR_WIDTH      (HDL_ADDR_WIDTH),
		.BURSTCOUNT_WIDTH    (BURSTCOUNT_WIDTH),
		.COMMAND_FIFO_DEPTH  (COMMAND_FIFO_DEPTH),
		.RESPONSE_FIFO_DEPTH (RESPONSE_FIFO_DEPTH),
		.MASTER_SYNC_DEPTH   (MASTER_SYNC_DEPTH),
		.SLAVE_SYNC_DEPTH    (SLAVE_SYNC_DEPTH),
		.SYNC_RESET          (SYNC_RESET)
	) hip_recfg_slave (
		.m0_clk           (m0_clk),           //   input,                 width = 1,   m0_clk.clk
		.m0_reset         (m0_reset),         //   input,                 width = 1, m0_reset.reset
		.s0_clk           (s0_clk),           //   input,                 width = 1,   s0_clk.clk
		.s0_reset         (s0_reset),         //   input,                 width = 1, s0_reset.reset
		.s0_waitrequest   (s0_waitrequest),   //  output,                 width = 1,       s0.waitrequest
		.s0_readdata      (s0_readdata),      //  output,        width = DATA_WIDTH,         .readdata
		.s0_readdatavalid (s0_readdatavalid), //  output,                 width = 1,         .readdatavalid
		.s0_burstcount    (s0_burstcount),    //   input,  width = BURSTCOUNT_WIDTH,         .burstcount
		.s0_writedata     (s0_writedata),     //   input,        width = DATA_WIDTH,         .writedata
		.s0_address       (s0_address),       //   input,    width = HDL_ADDR_WIDTH,         .address
		.s0_write         (s0_write),         //   input,                 width = 1,         .write
		.s0_read          (s0_read),          //   input,                 width = 1,         .read
		.s0_byteenable    (s0_byteenable),    //   input,                 width = 1,         .byteenable
		.s0_debugaccess   (s0_debugaccess),   //   input,                 width = 1,         .debugaccess
		.m0_waitrequest   (m0_waitrequest),   //   input,                 width = 1,       m0.waitrequest
		.m0_readdata      (m0_readdata),      //   input,        width = DATA_WIDTH,         .readdata
		.m0_readdatavalid (m0_readdatavalid), //   input,                 width = 1,         .readdatavalid
		.m0_burstcount    (m0_burstcount),    //  output,  width = BURSTCOUNT_WIDTH,         .burstcount
		.m0_writedata     (m0_writedata),     //  output,        width = DATA_WIDTH,         .writedata
		.m0_address       (m0_address),       //  output,    width = HDL_ADDR_WIDTH,         .address
		.m0_write         (m0_write),         //  output,                 width = 1,         .write
		.m0_read          (m0_read),          //  output,                 width = 1,         .read
		.m0_byteenable    (m0_byteenable),    //  output,                 width = 1,         .byteenable
		.m0_debugaccess   (m0_debugaccess)    //  output,                 width = 1,         .debugaccess
	);

endmodule
